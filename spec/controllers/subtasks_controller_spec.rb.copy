require 'spec_helper'
require 'capybara/rspec'
# require 'pp'
# require File.expand_path(File.dirname(__FILE__) + '/../spec_helper')
# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to specify the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator.  If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails.  There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.
#
# Compared to earlier versions of this generator, there is very limited use of
# stubs and message expectations in this spec.  Stubs are only used when there
# is no simpler way to get a handle on the object needed for the example.
# Message expectations are only used when there is no simpler way to specify
# that an instance is receiving a specific message.


describe SubtasksController, :type => :controller do
  # before :each do
  #   @task = FactoryGirl.create(:task)
  #   @subtask = FactoryGirl.build(:subtask)
  #   @subtask.task = @task
  # end

  # before(:each) do
  #   # http_login
  #   assign(Task, [
  #     stub_model(Task,
  #       :title => 'Vatamin#5',
  #       :course => 'CS186',
  #       :kind => 'Homework',
  #       :release => '27/Feb/2015 23:59:00 -0800',
  #       :due => '2/Mar/2015 23:59:00 -0800',
  #       :status => 'Complete',
  #       :user_id => 1
  #     ),
  #     stub_model(Task,
  #       :title => 'Quiz#2',
  #       :course => 'CS169',
  #       :kind => 'Exam',
  #       :release => '12/Mar/2015 23:59:00 -0800',
  #       :due => '19/Mar/2015 23:59:00 -0800',
  #       :status => 'New',
  #       :user_id => 1
  #     )
  #   ])
  # end

  before(:each) do
    login_user
    # login
    # visit new_user_session_path
    # fill_in "Login", :with => "xguo@berkeley.edu"
    # fill_in "Password", :with => "12345678"
    # click_button "Submit"

    # @task = FactoryGirl.create(:task)
    # @subtask = FactoryGirl.build(:subtask)
    # @subtask.task = @task

    # @task = mock_model(Task, :to_param => "1")
    # @task.stub_association!(:subtasks, :find => mock_model(Subtask))
    # Task.stub!(:find).and_return(@task)
    
    # Working Version
    @task = mock_model(Task)
    @subtasks = double("subtasks")
    @task.stub(:subtasks).and_return(@subtasks)
    Task.stub(:find).and_return(@task)
  end

  describe "GET show" do
    it "shoud rediect to the task path" do

      # get :index,{:task_id => '1'}
      # sign_in
      get :index, :task_id => '9'

      # pp task_subtask_path(@task, @subtask)
      # get task_subtasks_path(@task, @subtask)
      # get task_subtask_path(@task, @subtask)
      expect(response).to be_success
      expect(response).to render_template('index')
      # expect(response).to have_http_status(200)
      # subtask = Subtask.create! valid_attributes
      # get :show, {:id => subtask.to_param}, valid_session
      # assigns(:subtask).should eq(subtask)
    end
  end
end

# describe SubtasksController,  :type => :controller do

#   # This should return the minimal set of attributes required to create a valid
#   # Subtask. As you add validations to Subtask, be sure to
#   # adjust the attributes here as well.
#   let(:valid_attributes) { 
#       { "description" => "MyString", :is_done => false,  
#         :task => {
#           :id => 1, 
#           :title => "Midterm1", 
#           :due => "2015-03-07 07:59:00", 
#           :status => "New", 
#           :course => "CS164",
#           :kind => "Exam",
#           :release => "2015-03-05 07:59:00",
#           :created_at => "2015-03-12 00:22:01",
#           :updated_at => "2015-03-12 00:22:01",
#           :user_id => 1
#         }
#       } 
#     }

#   # This should return the minimal set of values that should be in the session
#   # in order to pass any filters (e.g. authentication) defined in
#   # SubtasksController. Be sure to keep this updated too.
#   let(:valid_session) { {} }
#   let(:params) { {:task_id => 1} }

#   # assign(:task, [
#   #     stub_model(Task,
#   #         :title => "Midterm1", 
#   #         :due => "2015-03-07 07:59:00", 
#   #         :status => "New", 
#   #         :course => "CS164",
#   #         :kind => "Exam",
#   #         :release => "2015-03-05 07:59:00",
#   #         :user_id => 1
#   #     )
#   #   ])
#   end


  # describe "GET index" do
  #   it "assigns all subtasks as @subtasks" do
  #     subtask = Subtask.create! valid_attributes
  #     get :index, {}, valid_session
  #     assigns(:subtasks).should eq([subtask])
  #   end
  # end

  


  # describe "GET new" do
  #   it "assigns a new subtask as @subtask" do
  #     get :new, {}, valid_session
  #     assigns(:subtask).should be_a_new(Subtask)
  #   end
  # end

  # describe "GET edit" do
  #   it "assigns the requested subtask as @subtask" do
  #     subtask = Subtask.create! valid_attributes
  #     get :edit, {:id => subtask.to_param}, valid_session
  #     assigns(:subtask).should eq(subtask)
  #   end
  # end

  # describe "POST create" do

  #   before(:each) do
  #     assign(:tasks, [
  #       stub_model(Task,
  #         :title => 'Vatamin#5',
  #         :course => 'CS186',
  #         :kind => 'Homework',
  #         :release => '27/Feb/2015 23:59:00 -0800',
  #         :due => '2/Mar/2015 23:59:00 -0800',
  #         :status => 'Complete',
  #         :user_id => 1
  #       ),
  #     ])
  #   end


  #   describe "with valid params" do
  #     it "creates a new Subtask" do
  #       expect {
  #         post :create, {:subtask => valid_attributes}, valid_session
  #       }.to change(Subtask, :count).by(1)
  #     end

  #     it "assigns a newly created subtask as @subtask" do
  #       post :create, {:subtask => valid_attributes}, valid_session
  #       assigns(:subtask).should be_a(Subtask)
  #       assigns(:subtask).should be_persisted
  #     end

  #     it "redirects to the created subtask" do
  #       post :create, {:subtask => valid_attributes}, valid_session
  #       response.should redirect_to(Subtask.last)
  #     end
  #   end

  #   describe "with invalid params" do
  #     it "assigns a newly created but unsaved subtask as @subtask" do
  #       # Trigger the behavior that occurs when invalid params are submitted
  #       Subtask.any_instance.stub(:save).and_return(false)
  #       post :create, {:subtask => { "description" => "invalid value" }}, valid_session
  #       assigns(:subtask).should be_a_new(Subtask)
  #     end

  #     it "re-renders the 'new' template" do
  #       # Trigger the behavior that occurs when invalid params are submitted
  #       Subtask.any_instance.stub(:save).and_return(false)
  #       post :create, {:subtask => { "description" => "invalid value" }}, valid_session
  #       response.should render_template("new")
  #     end
  #   end
  # end

  # describe "PUT update" do
  #   describe "with valid params" do
  #     it "updates the requested subtask" do
  #       subtask = Subtask.create! valid_attributes
  #       # Assuming there are no other subtasks in the database, this
  #       # specifies that the Subtask created on the previous line
  #       # receives the :update_attributes message with whatever params are
  #       # submitted in the request.
  #       Subtask.any_instance.should_receive(:update_attributes).with({ "description" => "MyString" })
  #       put :update, {:id => subtask.to_param, :subtask => { "description" => "MyString" }}, valid_session
  #     end

  #     it "assigns the requested subtask as @subtask" do
  #       subtask = Subtask.create! valid_attributes
  #       put :update, {:id => subtask.to_param, :subtask => valid_attributes}, valid_session
  #       assigns(:subtask).should eq(subtask)
  #     end

  #     it "redirects to the subtask" do
  #       subtask = Subtask.create! valid_attributes
  #       put :update, {:id => subtask.to_param, :subtask => valid_attributes}, valid_session
  #       response.should redirect_to(subtask)
  #     end
  #   end

  #   describe "with invalid params" do
  #     it "assigns the subtask as @subtask" do
  #       subtask = Subtask.create! valid_attributes
  #       # Trigger the behavior that occurs when invalid params are submitted
  #       Subtask.any_instance.stub(:save).and_return(false)
  #       put :update, {:id => subtask.to_param, :subtask => { "description" => "invalid value" }}, valid_session
  #       assigns(:subtask).should eq(subtask)
  #     end

  #     it "re-renders the 'edit' template" do
  #       subtask = Subtask.create! valid_attributes
  #       # Trigger the behavior that occurs when invalid params are submitted
  #       Subtask.any_instance.stub(:save).and_return(false)
  #       put :update, {:id => subtask.to_param, :subtask => { "description" => "invalid value" }}, valid_session
  #       response.should render_template("edit")
  #     end
  #   end
  # end

  # describe "DELETE destroy" do
  #   it "destroys the requested subtask" do
  #     subtask = Subtask.create! valid_attributes
  #     expect {
  #       delete :destroy, {:id => subtask.to_param}, valid_session
  #     }.to change(Subtask, :count).by(-1)
  #   end

  #   it "redirects to the subtasks list" do
  #     subtask = Subtask.create! valid_attributes
  #     delete :destroy, {:id => subtask.to_param}, valid_session
  #     response.should redirect_to(subtasks_url)
  #   end
  # end

# end